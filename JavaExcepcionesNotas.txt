

		**** Java Excepciones *****
https://github.com/alura-es-cursos/java-herencia-polimorfismo/tree/clase-7

¿Por qué la JVM usa un Stack?
- Para saber cuál método está siendo ejecutado.
Una pila de Java es parte de la JVM y almacena los métodos que se están ejecutando. 
Además del bloque de código, la pila almacena las variables y referencias de ese 
bloque. Entonces, la JVM organiza la ejecución y sabe exactamente qué método se 
está ejecutando, que es siempre el método en la parte superior de la pila. 
La JVM también sabe qué otros aún deben ejecutarse, que son precisamente los 
métodos que continúan.

-Para organizar la ejecución de los métodos.
Una pila de Java es parte de la JVM y almacena los métodos que se están ejecutando. 
Además del bloque de código, la pila almacena las variables y referencias de ese 
bloque. Entonces, la JVM organiza la ejecución y sabe exactamente qué método se está
ejecutando, que es siempre el método en la parte superior de la pila. La JVM también
sabe qué otros aún deben ejecutarse, que son precisamente los métodos que continúan.

La excepciones son objetos que tiene nombre, mensaje.
 Los errores que queremos controlar nos ayudará a crear las excepciones.

Las excepciones en Java:
- Las excepciones no controladas caen en la pila de ejecución en busca de alguien 
que pueda manejarlas.
- Toda excepción en Java tiene un nombre que la idenfica. Este enfoque hace que 
sea más fácil de entender que usar números mágicos (códigos de error) como 15, 7012 o 16.

El código anterior a través de Multi- Catch:
try {
    System.out.println(1 / 0);
} catch (ArithmeticException | NullPointerException ex) { 
    ex.printStackTrace();
}
A través de un | (pipe) en la cláusula catch, podemos capturar más de una excepción.
Con eso, podemos tener un solo bloque para manejar una o más excepciones.


Si no se maneja, la excepción cambia el flujo de ejecución del programa.
Si no se trata, la excepción cambia el flujo de ejecución del programa y finalizándolo abruptamente.

Para manejar la excepción, use el bloque try y catch.
Con el bloque try y catch, manejamos una excepción que puede ocurrir mientras 
nuestro programa se está ejecutando, tratándolo de antemano con un código específico.

throw ae; //throw - Lanza la excepcion: lanza la bomba
//abajo del throw no debe haber lineas de codigo porque no sera ejecutadas.
//Solo podemos hacer throw de objetos que son excepciones

No es suficiente crear una instancia de la excepción, es necesario lanzarlo a 
través del throw.

private static void metodo2() {
    System.out.println("Inicio del metodo2"); 
    ArithmeticException exception = new ArithmeticException();
    throw exception;
}


      //Solo podemos hacer throw de objetos que son excepciones ya que extendienden o heredan de throwable
   		
			Throwable
			/	 \
		exception	 errores
		      |			\
	   	   RuntimeException    StackOverflowError
		  /	\	  \
ArithmeticException   MiException  NullPointerException

Exception: Son el tipo de errores que retornamos los que programamos sobre la JVM
los que programamos hacemos features sobre la JVM.
Error: los errores son el tipo de errores retornados, por los que programan la JVM

Creamos una exception que extiende de exception

				Throwable
				/	 \
			exception	  errores
		       /			 \
	    MiException |      RuntimeException    StackOverflowError
	 		|      	/      	       \	  	
		        |   ArithmeticException \
			|		         \
			|			NullPointerException
			|
	CHECKED		| 	UNCHECKED	
	(Verificado) 	|	(No Verificado)

En RuntimeException: Puede ser que si o no, que lanze la excepcion, Excepciones no Verificada por el compilador.
En Exception: Le digo el va a lanzar esa Exception. Excepcion Verificada al momento de compilador.

La excepcion UNCHECKED(No verificado): estas excepciones no son verificadas por el
compilador, puede que lance o no, el compilador no va a alertar por si acaso el lanzo o no
el no hará el trabajo.

La excepcion CHECKED(verificado) el compilador si nos va a obligar a tratar, esa
excepcion si es lanzada en alguna parte del codigo, si no, no va a compilar.Nos aparecera
un error. Es necessario atrapar la excepcion con el try y catch.


Miguel estudió esta clase cuidadosamente y tomó las notas que se encuentran a 
continuación:

1) Existe una gran jerarquía de clases que representan excepciones. 
Por ejemplo, ArithmeticException es hija de RuntimeException, que hereda de 
Exception, que a su vez es hija de la clase de excepciones más ancestral, Throwable.
Conocer bien esta jerarquía significa saber cómo usar las excepciones en su aplicación.

2) Throwable es la clase que necesita ser extendida para poder lanzar un objeto en 
la pila (usando la palabra reservada throw).

3) La jerarquía que comenzó con la clase Throwable se divide en excepciones y 
errores. Las clases que informan de errores de máquinas virtuales heredan de Error.

4) StackOverflowError es un error de la máquina virtual para informar que la pila de 
ejecución no tiene más memoria.

5) Las excepciones se dividen en dos grandes categorías: las que el compilador 
comprueba obligatoriamente y las que no. Los primeros se denominan checked y se 
crean al pertenecer a una jerarquía que no pasa por RuntimeException. Los segundos 
son unchecked y se crean como descendientes de RuntimeException.


En la clase ConexionException, basta extender la clase RuntimeExeption en lugar de Exception.
De esta manera, se torna un unchecked y el compilador no obliga más a "tomar una acción”.

Las exeption nos sirven para el control de errores mas detallado. 















